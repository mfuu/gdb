<!DOCTYPE html><html lang="en" class="false"><head><meta charset="UTF-8"><style>:where(img){height:auto}</style><meta name="viewport" content="width=device-width"><link rel="icon" type="image/svg+xml" href="/gdb/favicon.svg"><link rel="canonical" href="https://mfuu.github.io/gdb/search/"><meta name="generator" content="Astro v4.16.18"><!-- General Meta Tags --><title>Search | GDB</title><meta name="title" content="Search | GDB"><meta name="description" content="A minimal, responsive and SEO-friendly Astro blog theme."><meta name="author" content="mfuu"><link rel="sitemap" href="/gdb/sitemap-index.xml"><!-- Open Graph / Facebook --><meta property="og:title" content="Search | GDB"><meta property="og:description" content="A minimal, responsive and SEO-friendly Astro blog theme."><meta property="og:url" content="https://mfuu.github.io/gdb/search/"><meta property="og:image" content="https://mfuu.github.io/gdb/astropaper-og.jpg"><!-- Article Published/Modified time --><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://mfuu.github.io/gdb/search/"><meta property="twitter:title" content="Search | GDB"><meta property="twitter:description" content="A minimal, responsive and SEO-friendly Astro blog theme."><meta property="twitter:image" content="https://mfuu.github.io/gdb/astropaper-og.jpg"><!-- Google Font --><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,400;0,500;0,600;0,700;1,400;1,600&amp;display=swap" rel="stylesheet"><meta name="theme-color" content=""><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script src="/gdb/toggle-theme.js"></script><link rel="stylesheet" href="/gdb/astro-assets/about.1SVk4tPg.css">
<style>#main-content:where(.astro-hsp6otuf){width:100%;max-width:48rem;margin-left:auto;margin-right:auto;padding-bottom:1rem;padding-left:1rem;padding-right:1rem}#main-content:where(.astro-hsp6otuf) h1:where(.astro-hsp6otuf){font-size:1.5rem;font-weight:600;line-height:2rem}@media (min-width:640px){#main-content:where(.astro-hsp6otuf) h1:where(.astro-hsp6otuf){font-size:1.875rem;line-height:2.25rem}}#main-content:where(.astro-hsp6otuf) p:where(.astro-hsp6otuf){margin-top:.5rem;margin-bottom:1.5rem;font-style:italic}@keyframes astroFadeInOut{0%{opacity:1}to{opacity:0}}@keyframes astroFadeIn{0%{opacity:0;mix-blend-mode:plus-lighter}to{opacity:1;mix-blend-mode:plus-lighter}}@keyframes astroFadeOut{0%{opacity:1;mix-blend-mode:plus-lighter}to{opacity:0;mix-blend-mode:plus-lighter}}@keyframes astroSlideFromRight{0%{transform:translate(100%)}}@keyframes astroSlideFromLeft{0%{transform:translate(-100%)}}@keyframes astroSlideToRight{to{transform:translate(100%)}}@keyframes astroSlideToLeft{to{transform:translate(-100%)}}@media (prefers-reduced-motion){::view-transition-group(*){animation:none!important}::view-transition-old(*){animation:none!important}::view-transition-new(*){animation:none!important}[data-astro-transition-scope]{animation:none!important}}.breadcrumb:where(.astro-ilhxcym7){width:100%;max-width:48rem;margin:2rem auto .25rem;padding-left:1rem;padding-right:1rem}.breadcrumb:where(.astro-ilhxcym7) ul:where(.astro-ilhxcym7) li:where(.astro-ilhxcym7){display:inline}.breadcrumb:where(.astro-ilhxcym7) ul:where(.astro-ilhxcym7) li:where(.astro-ilhxcym7) a:where(.astro-ilhxcym7){text-transform:capitalize;opacity:.7}.breadcrumb:where(.astro-ilhxcym7) ul:where(.astro-ilhxcym7) li:where(.astro-ilhxcym7) span:where(.astro-ilhxcym7){opacity:.7}.breadcrumb:where(.astro-ilhxcym7) ul:where(.astro-ilhxcym7) li:where(.astro-ilhxcym7):not(:last-child) a:where(.astro-ilhxcym7):hover{opacity:1}</style><script type="module" src="/gdb/astro-assets/hoisted.VFObjY0O.js"></script></head> <body>  <header class="astro-3ef6ksr2"> <a id="skip-to-content" href="#main-content" class="astro-3ef6ksr2">Skip to content</a> <div class="astro-3ef6ksr2 nav-container"> <div class="astro-3ef6ksr2 top-nav-wrap"> <a href="/gdb/" class="astro-3ef6ksr2 logo whitespace-nowrap"> GDB </a> <nav id="nav-menu" class="astro-3ef6ksr2"> <button class="astro-3ef6ksr2 focus-outline hamburger-menu" aria-label="Open Menu" aria-expanded="false" aria-controls="menu-items"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="astro-3ef6ksr2 menu-icon"> <line x1="7" y1="12" x2="21" y2="12" class="astro-3ef6ksr2 line"></line> <line x1="3" y1="6" x2="21" y2="6" class="astro-3ef6ksr2 line"></line> <line x1="12" y1="18" x2="21" y2="18" class="astro-3ef6ksr2 line"></line> <line x1="18" y1="6" x2="6" y2="18" class="astro-3ef6ksr2 close"></line> <line x1="6" y1="6" x2="18" y2="18" class="astro-3ef6ksr2 close"></line> </svg> </button> <ul id="menu-items" class="astro-3ef6ksr2 display-none sm:flex"> <li class="astro-3ef6ksr2"> <a href="/gdb/posts/" class="astro-3ef6ksr2"> posts </a> </li><li class="astro-3ef6ksr2"> <a href="/gdb/tags/" class="astro-3ef6ksr2"> tags </a> </li><li class="astro-3ef6ksr2"> <a href="/gdb/about/" class="astro-3ef6ksr2"> about </a> </li> <li class="astro-3ef6ksr2"> <a href="/gdb/search/" class="astro-3ef6ksr2 focus-outline active flex group hover:text-skin-accent inline-block p-3 sm:p-1" aria-label="search" title="Search"> <svg xmlns="http://www.w3.org/2000/svg" class="astro-3ef6ksr2 scale-125 sm:scale-100"><path d="M19.023 16.977a35.13 35.13 0 0 1-1.367-1.384c-.372-.378-.596-.653-.596-.653l-2.8-1.337A6.962 6.962 0 0 0 16 9c0-3.859-3.14-7-7-7S2 5.141 2 9s3.14 7 7 7c1.763 0 3.37-.66 4.603-1.739l1.337 2.8s.275.224.653.596c.387.363.896.854 1.384 1.367l1.358 1.392.604.646 2.121-2.121-.646-.604c-.379-.372-.885-.866-1.391-1.36zM9 14c-2.757 0-5-2.243-5-5s2.243-5 5-5 5 2.243 5 5-2.243 5-5 5z" class="astro-3ef6ksr2"></path> </svg> <span class="astro-3ef6ksr2 sr-only">Search</span> </a> </li> <li class="astro-3ef6ksr2"> <button id="theme-btn" class="astro-3ef6ksr2 focus-outline" title="Toggles light &amp; dark" aria-label="auto" aria-live="polite"> <svg xmlns="http://www.w3.org/2000/svg" id="moon-svg" class="astro-3ef6ksr2"> <path d="M20.742 13.045a8.088 8.088 0 0 1-2.077.271c-2.135 0-4.14-.83-5.646-2.336a8.025 8.025 0 0 1-2.064-7.723A1 1 0 0 0 9.73 2.034a10.014 10.014 0 0 0-4.489 2.582c-3.898 3.898-3.898 10.243 0 14.143a9.937 9.937 0 0 0 7.072 2.93 9.93 9.93 0 0 0 7.07-2.929 10.007 10.007 0 0 0 2.583-4.491 1.001 1.001 0 0 0-1.224-1.224zm-2.772 4.301a7.947 7.947 0 0 1-5.656 2.343 7.953 7.953 0 0 1-5.658-2.344c-3.118-3.119-3.118-8.195 0-11.314a7.923 7.923 0 0 1 2.06-1.483 10.027 10.027 0 0 0 2.89 7.848 9.972 9.972 0 0 0 7.848 2.891 8.036 8.036 0 0 1-1.484 2.059z" class="astro-3ef6ksr2"></path> </svg> <svg xmlns="http://www.w3.org/2000/svg" id="sun-svg" class="astro-3ef6ksr2"> <path d="M6.993 12c0 2.761 2.246 5.007 5.007 5.007s5.007-2.246 5.007-5.007S14.761 6.993 12 6.993 6.993 9.239 6.993 12zM12 8.993c1.658 0 3.007 1.349 3.007 3.007S13.658 15.007 12 15.007 8.993 13.658 8.993 12 10.342 8.993 12 8.993zM10.998 19h2v3h-2zm0-17h2v3h-2zm-9 9h3v2h-3zm17 0h3v2h-3zM4.219 18.363l2.12-2.122 1.415 1.414-2.12 2.122zM16.24 6.344l2.122-2.122 1.414 1.414-2.122 2.122zM6.342 7.759 4.22 5.637l1.415-1.414 2.12 2.122zm13.434 10.605-1.414 1.414-2.122-2.122 1.414-1.414z" class="astro-3ef6ksr2"></path> </svg> </button> </li> </ul> </nav> </div> </div> <div class="max-w-3xl mx-auto px-4"> <hr class="border-skin-line" aria-hidden="true"> </div> </header>   <nav class="astro-ilhxcym7 breadcrumb" aria-label="breadcrumb"> <ul class="astro-ilhxcym7"> <li class="astro-ilhxcym7"> <a href="/gdb/" class="astro-ilhxcym7">Home</a> <span aria-hidden="true" class="astro-ilhxcym7">»</span> </li> <li class="astro-ilhxcym7"> <span class="astro-ilhxcym7 capitalize" aria-current="page">  search </span> </li> </ul> </nav>  <main id="main-content" class="astro-hsp6otuf"> <h1 class="astro-hsp6otuf">Search</h1> <p class="astro-hsp6otuf">Search any article ...</p>  <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var u=async m=>{await(await m())()};(self.Astro||(self.Astro={})).load=u,window.dispatchEvent(new Event("astro:load"))})(),(()=>{var u=Object.defineProperty,m=(o,s,a)=>s in o?u(o,s,{enumerable:!0,configurable:!0,writable:!0,value:a}):o[s]=a,c=(o,s,a)=>m(o,typeof s!="symbol"?s+"":s,a);{let o={0:t=>b(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},s=t=>{let[e,r]=t;return e in o?o[e](r):void 0},a=t=>t.map(s),b=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([e,r])=>[e,s(r)]));class v extends HTMLElement{constructor(){super(...arguments),c(this,"Component"),c(this,"hydrator"),c(this,"hydrate",async()=>{var e;if(!this.hydrator||!this.isConnected)return;let r=(e=this.parentElement)==null?void 0:e.closest("astro-island[ssr]");if(r){r.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let i=this.querySelectorAll("astro-slot"),d={},p=this.querySelectorAll("template[data-astro-template]");for(let n of p){let l=n.closest(this.tagName);l!=null&&l.isSameNode(this)&&(d[n.getAttribute("data-astro-template")||"default"]=n.innerHTML,n.remove())}for(let n of i){let l=n.closest(this.tagName);l!=null&&l.isSameNode(this)&&(d[n.getAttribute("name")||"default"]=n.innerHTML)}let h;try{h=this.hasAttribute("props")?b(JSON.parse(this.getAttribute("props"))):{}}catch(n){let l=this.getAttribute("component-url")||"<unknown>",f=this.getAttribute("component-export");throw f&&(l+=` (export ${f})`),console.error(`[hydrate] Error parsing props for component ${l}`,this.getAttribute("props"),n),n}let y;await this.hydrator(this)(this.Component,h,d,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))}),c(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),r.disconnect(),this.childrenConnectedCallback()},r=new MutationObserver(()=>{var i;((i=this.lastChild)==null?void 0:i.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});r.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),r=this.getAttribute("client");if(Astro[r]===void 0){window.addEventListener(`astro:${r}`,()=>this.start(),{once:!0});return}try{await Astro[r](async()=>{let i=this.getAttribute("renderer-url"),[d,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),i?import(i):()=>()=>{}]),h=this.getAttribute("component-export")||"default";if(!h.includes("."))this.Component=d[h];else{this.Component=d;for(let y of h.split("."))this.Component=this.Component[y]}return this.hydrator=p,this.hydrate},e,this)}catch(i){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,i)}}attributeChangedCallback(){this.hydrate()}}c(v,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",v)}})();
</script><astro-island uid="Z22fp0N" prefix="r0" component-url="/gdb/astro-assets/Search.DsLf6brg.js" component-export="default" renderer-url="/gdb/astro-assets/client.f-r63Uvi.js" props="{&quot;searchList&quot;:[1,[[0,{&quot;id&quot;:[0,&quot;gitsubmodule.md&quot;],&quot;slug&quot;:[0,&quot;gitsubmodule&quot;],&quot;body&quot;:[0,&quot;### 添加\n```\ngit submodule add <url> <path>\n```\n  * url：子模块仓库地址\n  * path：本地存放路径\n\n### 初始化\n```\ngit submodule update --init --recursive\n```\n或者\n```\ngit submodule init\ngit submodule update\n```\n\n### 更新\n```\ncd <path>\ngit pull origin <branch>\n```\n\n### 删除\n\n* 删除submodule缓存\n  ```\n  git rm --cached <path>\n  ```\n\n* 删除submodule目录\n  ```\n  rm -rf <path>\n  ```\n\n* 删除文件 `.gitmodules` 中对应子模块内容\n\n* 删除 `.git/modules` 对应子模块目录\n  ```\n  rm -rf .git/modules/<path>\n  ```\n\n* 删除 `.git/config` 中对应子模块内容\n&quot;],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;data&quot;:[0,{&quot;author&quot;:[0,&quot;mfuu&quot;],&quot;pubDatetime&quot;:[3,&quot;2025-01-02T02:34:25.000Z&quot;],&quot;modDatetime&quot;:[3,&quot;2025-01-02T02:34:26.000Z&quot;],&quot;title&quot;:[0,&quot;git submodule&quot;],&quot;featured&quot;:[0,false],&quot;tags&quot;:[1,[[0,&quot;git&quot;]]],&quot;description&quot;:[0,&quot;git submodule&quot;],&quot;discussionNumber&quot;:[0,11]}],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;前后端异常httphttps请求返回415错误状态码.md&quot;],&quot;slug&quot;:[0,&quot;前后端异常httphttps请求返回415错误状态码&quot;],&quot;body&quot;:[0,&quot;### 一、问题描述\n\n![image](https://github.com/user-attachments/assets/f615e3b8-ebec-4ffc-be07-b5e4d63d6f8c)\n\n### 二、错误原因\n\n以下解释来源[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/415)：\n> 415 Unsupported Media Type 是一种 HTTP 协议的错误状态代码，表示服务器由于不支持其有效载荷的格式，从而拒绝接受客户端的请求。\n\n具体原因：请求头中未携带 ”Content-Type“ 或与接口注解不一致\n\n### 三、解决方案\n\n针对我遇到的问题，前端在请求头中添加`”Content-Type“: \&quot;application/json\&quot;`即可解决&quot;],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;data&quot;:[0,{&quot;author&quot;:[0,&quot;mfuu&quot;],&quot;pubDatetime&quot;:[3,&quot;2024-08-22T02:27:10.000Z&quot;],&quot;modDatetime&quot;:[3,&quot;2024-08-22T02:27:11.000Z&quot;],&quot;title&quot;:[0,&quot;【前后端异常】http/https 请求返回415错误状态码&quot;],&quot;featured&quot;:[0,false],&quot;tags&quot;:[1,[[0,&quot;http&quot;]]],&quot;description&quot;:[0,&quot;【前后端异常】http/https 请求返回415错误状态码&quot;],&quot;discussionNumber&quot;:[0,10]}],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;angular实现类似Vue中的slot用法.md&quot;],&quot;slug&quot;:[0,&quot;angular实现类似vue中的slot用法&quot;],&quot;body&quot;:[0,&quot;## 方案一：Directive\n\n**`item.directive.ts`**\n\n```ts\nimport {\n  Input,\n  Directive,\n  TemplateRef,\n  EmbeddedViewRef,\n  ViewContainerRef,\n} from '@angular/core';\n\n@Directive({\n  selector: '[ListItem]',\n})\nexport class ListItem {\n  private _context: any;\n  private _viewRef: EmbeddedViewRef<any>;\n\n  constructor(\n    private viewContainer: ViewContainerRef,\n    public templateRef: TemplateRef<any>\n  ) {\n    this._viewRef = this.viewContainer.createEmbeddedView(templateRef);\n  }\n\n  @Input()\n  set ItemDirective(source: any) {\n    this._context = source;\n  }\n\n  ngAfterViewInit(): void {\n    // get the real dom:\n    // this._viewRef.rootNodes.find((item) => item.nodeType !== 8);\n  }\n}\n```\n\n**`list.component.ts`**\n\n```ts\n@Component({\n  selector: 'list, [list]',\n  template: `\n    <ng-container *ngFor=\&quot;let item of items\&quot;>\n      <ng-template [ListItem]=\&quot;item\&quot;>\n        <ng-container\n          *ngTemplateOutlet=\&quot;\n            listItemTemplateRef;\n            context: { $implicit: item }\n          \&quot;\n        ></ng-container>\n      </ng-template>\n    </ng-container>\n  `,\n})\nexport class ListComponent implements OnInit {\n  @Input() items = [];\n}\n```\n\n**如何使用：**\n\n```ts\n@Component({\n  selector: 'tester',\n  template: `\n    <list [items]=\&quot;items\&quot;>\n      <ng-template let-data>\n        <p>{{ data.id }}</p>\n      </ng-template>\n    </list>\n  `,\n  styles: [],\n})\nexport class TesterComponent {\n  public items = [\n    { id: 'a', text: 'aaa' },\n    { id: 'b', text: 'bbb' },\n    { id: 'c', text: 'ccc' },\n    ...\n  ];\n}\n```\n\n**缺点：**\n\n使用这种方式可能会渲染较多的注释片段，由于angular在开发模式下会添加注释来帮助开发者理解数据绑定的状态，但在生产模式中通常会被移除。\n\n打开Element可能会看见以下信息：\n```\n<!--bindings={\n  \&quot;ng-reflect-ng-template-outlet-context\&quot;: \&quot;[object Object]\&quot;\n}-->\n<!--bindings={\n  \&quot;ng-reflect-is-horizontal\&quot;: \&quot;false\&quot;\n}-->\n<!--ng-container-->\n```\n\n\n## 方案二：Directive + viewContainerRef\n\n**`item.directive.ts`**\n\n```ts\nimport { Directive, TemplateRef } from '@angular/core';\n\n@Directive({\n  selector: '[ListItem]',\n})\nexport class VirtualItem {\n  constructor(public templateRef: TemplateRef<any>) {}\n}\n```\n\n**`list.component.ts`**\n\n```ts\nimport { ViewContainerRef } from '@angular/core';\nimport { ListItem } from \&quot;./item.directive\&quot;;\n\n@Component({\n  selector: 'list, [list]',\n  template: `\n    <ng-container #viewContainer></ng-container>\n  `,\n})\nexport class ListComponent implements OnInit {\n  @Input() items = [];\n\n  @ViewChild(\&quot;hostView\&quot;, { read: ViewContainerRef, static: true })\n  public viewContainerRef!: ViewContainerRef;\n\n  @ContentChild(ListItem)\n  @DeclareState()\n  public ListItem!;\n\n  public renders = [];\n  // 渲染列表内容\n  renderItems() {\n    // 如果内容有变化，先清除已渲染内容\n\tthis.viewContainerRef.clear();\n\tthis.renders = [];\n\t\n\tthis.items.forEach((item, index) => {\n\t  this.renders.push(\n\t\tthis.viewContainerRef.createEmbeddedView(\n\t\t  this.ListItem.templateRef,\n\t\t  { $implicit: item, index }\n\t\t)\n\t  );\n\t});\n  }\n}\n```\n\n**如何使用：**\n\n```ts\n@Component({\n  selector: 'tester',\n  template: `\n    <list [items]=\&quot;items\&quot;>\n      <div *ListItem=\&quot;let item\&quot;>\n        <p>{{ item.text }}</p>\n      </div>\n    </list>\n  `,\n  styles: [],\n})\nexport class TesterComponent {\n  public items = [\n    { id: 'a', text: 'aaa' },\n    { id: 'b', text: 'bbb' },\n    { id: 'c', text: 'ccc' },\n    ...\n  ];\n}\n```\n&quot;],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;data&quot;:[0,{&quot;author&quot;:[0,&quot;mfuu&quot;],&quot;pubDatetime&quot;:[3,&quot;2024-07-12T09:22:59.000Z&quot;],&quot;modDatetime&quot;:[3,&quot;2024-08-07T03:07:36.000Z&quot;],&quot;title&quot;:[0,&quot;angular实现类似Vue中的slot用法&quot;],&quot;featured&quot;:[0,false],&quot;tags&quot;:[1,[[0,&quot;angular&quot;]]],&quot;description&quot;:[0,&quot;angular实现类似Vue中的slot用法&quot;],&quot;discussionNumber&quot;:[0,9]}],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;TCP与UDP.md&quot;],&quot;slug&quot;:[0,&quot;tcp与udp&quot;],&quot;body&quot;:[0,&quot;# UDP\n\n### 面向报文\n\n&amp;emsp;&amp;emsp;UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作。\n具体来说\n* 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了\n* 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会有任何拼接操作\n\n### 不可靠性\n* UDP 是无连接的，也就是说通信不需要建立和断开连接\n* UDP 也是不可靠的，协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的\n* UDP 没有拥塞控制，一直会以恒定的速度发送数据，即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是TCP\n\n### 高效\n\n&amp;emsp;&amp;emsp;因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达，所以 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。\n\n![udp-header](https://user-images.githubusercontent.com/51625532/154191932-b03e56e2-9b92-4c4e-aaf3-cf1509b5ca67.png)\n\nUDP 头部包含了以下几个数据：\n* 两个十六位的端口号，分别为源端口（可选字段）和目标端口\n* 整个数据报文的长度\n* 整个数据报文的检验和（IPV4 可选字段），该字段用于发现头部信息和数据中的错误\n\n### 传输方式\n\n&amp;emsp;&amp;emsp;UDP不止支持一对一的传输方式，同样支持一对多、多对多、多对一的方式，也就是说 UDP 提供了单播、多播、广播的功能\n\n# TCP\n### 头部\n\nTCP 头部比 UDP 头部复杂的多\n\n![tcp-header](https://user-images.githubusercontent.com/51625532/154201621-8732500b-be89-4df4-86ad-8d1ae30b7fe6.png)\n\n对于 TCP 头部来说，以下几个字段是很重要的\n* Sequence number（序号），这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序拼接报文\n* Acknowledgement number（确认号），这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到\n* Window Size（窗口大小），标识还能接收多少字节的数据，用于流量控制\n* 标识符\n  * URG=1：该字段表示本数据包的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部\n  * ACK=1：该字段表示确认号字段有效，此外，TCP 还规定在连接建立后传送的所有报文字段都必须把 ACK 置为一\n  * PSH=1：该字段表示接收端应该立即将数据push给应用层，而不是等到缓冲区满后再提交\n  * RST=1：该字段表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文和拒绝连接请求\n  * SYN=1：当 SYN=1，ACK=0 时，表示当前报文段是一个连接请求报文；当 SYN=1，ACK=1 时，表示当前报文段是一个同意建立连接的应答报文\n  * FIN=1：该字段表示此报文段是一个释放连接的请求报文\n\n\n### 建立链接三次握手\n\n![tcp-link](https://user-images.githubusercontent.com/51625532/154204663-c92c4941-069f-40b0-b424-dd76299c6be3.jpg)\n\n&amp;emsp;&amp;emsp;在 TCP 协议中，主动发起请求的一端为客户端，被动连接的一端为服务端。不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 也是一个全双工的协议。\n\n&amp;emsp;&amp;emsp;起初，两端都为 CLOSED 状态，在通信开始前，双方都会创建 TCB。服务器创建完 TCB 后进入 LISTEN 状态，此时开始等待客户端发送数据。\n* **第一次握手**：客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态，x 表示客户端的数据通信初始序号\n* **第二次握手**：服务端收到连接请求报文后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态\n* **第三次握手**：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功\n\n`PS：第三次握手可以包含数据，通过 TCP 快速打开（TFO）技术。起始只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端存储相同 cookie ，下次握手时发出 cookie 达到减少 RTT 的目的。`\n\n> **明明两次握手就可以建立起连接，为什么还需要第三次应答？**\n\n&amp;emsp;&amp;emsp;因为这是为了防止失效的连接请求报文段被服务端接收，从而产生错误。举个例子：\n\n&amp;emsp;&amp;emsp;客户端发送了一个连接请求A，但是因为网络原因造成了超时，这是 TCP 会启动超时重传的机制再次发送一个连接请求B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求A在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端一直等待，造成资源浪费。\n`（在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN FLOOD 攻击。遇到这种情况可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求）`\n\n### 断开链接四次握手\n\n![tcp-close](https://user-images.githubusercontent.com/51625532/154208235-64e2609d-aa90-4a8a-bd92-cd48cd233f8b.jpg)\n\n&amp;emsp;&amp;emsp;TCP是全双工的，在断开连接时两端都需要发送 FIN 和 ACK\n* **第一次握手**：若客户端认为数据发送完成，则它需要向服务端发送连接释放请求\n* **第二次握手**：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后回发送 ACK 包，并进入 CLOSE-WAIT 状态，表示客户端到服务端的连接已经释放，不接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端\n* **第三次握手**：服务端如果此时还有未发完的数据则会继续发送，发送完后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。`通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送`\n* **第四次握手**：客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃），若该时间段内没有服务端的重发请求，就进入 CLOSED 状态。当服务端收到确认应答后，也进入 CLOSED 状态\n\n> **为什么客户端要进入TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？**\n\n&amp;emsp;&amp;emsp;为了保证服务端能收到客户端的确认应答。若客户端发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成服务端不能正常关闭。\n\n### 常见面试题\n\n> **为什么连接的时候是三次握手，关闭的时候却是四次握手？**\n* 关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据，但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方，再发送 FIN 报文给对方来表示同意现在关闭连接\n* 因此，ACK 和 FIN 一般都会分开发送，从而导致多了一次\n\n> **为什么不能用两次握手进行连接？**\n* 若建立连接只需要两次握手，客户端并没有太大变化，任然需要获得服务端的应答后才进入 ESTABLISHED 状态，而服务端在收到连接请求后就进入 ESTABLISHED 状态。\n* 此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确认并确认应答，双方便开始通信，通信结束后释放连接。此时如果失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入 ESTABLISHED 状态，等待发送数据或主动发送数据\n* 但此时客户端早已进入 CLOSED 状态马，服务端会一直等待，浪费服务端连接资源\n\n> **如果已经建立了连接，但是客户端突然出现故障了怎么办？**\n* TCP保活计时器每次客户端请求服务器会重置计时器，当2小时之内没收到客户端任何数据时，会每隔75s向客户端发一个探测报文，若接连发送10个，客户端都没有反应，则认为客户端故障，关闭连接。\n\n> **什么是SYN洪泛攻击？**\n* SYN洪泛攻击就是利用TCP协议的特性（三次握手）。攻击者发送TCP的 SYN，SYN是TCP三次握手中第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。\n* 这样更加会浪费服务器资源。攻击者就对服务器发送大量的这种TCP连接，由于每一个连接都无法完成三次握手，所以就在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机。\n\n\n**推荐文章**\n\n* [前端需要了解的计算机网络知识， 这一篇就够了！](https://juejin.cn/post/6844904079974465544#heading-39)\n* [TCP详解](https://www.cnblogs.com/yueminghai/p/6646043.html)&quot;],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;data&quot;:[0,{&quot;author&quot;:[0,&quot;mfuu&quot;],&quot;pubDatetime&quot;:[3,&quot;2024-07-03T14:17:30.000Z&quot;],&quot;modDatetime&quot;:[3,&quot;2024-07-03T14:17:31.000Z&quot;],&quot;title&quot;:[0,&quot;TCP与UDP&quot;],&quot;featured&quot;:[0,false],&quot;tags&quot;:[1,[[0,&quot;http&quot;]]],&quot;description&quot;:[0,&quot;TCP与UDP&quot;],&quot;discussionNumber&quot;:[0,7]}],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;Vue2使用slot跨组件传递信息.md&quot;],&quot;slug&quot;:[0,&quot;vue2使用slot跨组件传递信息&quot;],&quot;body&quot;:[0,&quot;### 父组件\n\n**`Parent.vue`**\n\n```vue\n<template>\n  <div class=\&quot;parent\&quot;>\n    <Child>\n      <span #slot1=\&quot;{ item, index }\&quot;>{{ index }}</span>\n      <span #slot2=\&quot;{ item, index }\&quot;>{{ index }}</span>\n    </Child>\n  </div>\n</template>\n\n<script>\nimport Child from './Child.vue'\nexport default {\n  name: \&quot;parent\&quot;\n}\n</script>\n```\n\n**`Parent.jsx`**\n\n```jsx\nimport Child from './Child.jsx'\nconst Parent = Vue.component('parent', {\n  render() {\n    return (\n      <div className=\&quot;parent\&quot;>\n        <Child\n          scopedSlots={\n            {\n              slot1: props => {\n                return <span>{ props.index }</span>\n              },\n              slot2: props => {\n                return <span>{ props.index }</span>\n              }\n            }\n          }\n        ></Child>\n      </div>\n    )\n  }\n})\n```\n\n### 子组件\n\n**`Child.vue`**\n\n```vue\n<template>\n  <div class=\&quot;child\&quot;>\n    <Sun>\n      <template v-for=\&quot;(index, name) in $scopedSlots\&quot; v-slot:[name]=\&quot;data\&quot;>\n        <slot :name=\&quot;name\&quot; v-bind=\&quot;data\&quot;></slot>\n      </template>\n    </Sun>\n  </div>\n</template>\n\n<script>\nimport Sun from './Sun.vue'\nexport default {\n  name: \&quot;child\&quot;\n}\n</script>\n```\n\n**`Child.jsx`**\n\n```jsx\nimport Sun from 'Sun.jsx'\nconst Child = Vue.component('child', {\n  methods: {\n    scopedSlots() {\n      let result = {}\n      Object.keys(this.$scopedSlots).forEach((name) => {\n        result[name] = (props) => this.$scopedSlots[name](props)\n      })\n      return result\n    }\n  },\n  render() {\n    return (\n      <div className=\&quot;child\&quot;>\n        <Sun\n          scopedSlots={{\n            ...this.scopedSlots()\n          }}\n        ></Sun>\n      </div>\n    )\n  }\n})\n```\n\n### 孙组件\n\n**`Sun.vue`**\n\n```vue\n<template>\n  <div class=\&quot;sun\&quot;>\n    <template v-for=\&quot;(name, index) in slots\&quot;>\n      <slot :name=\&quot;name\&quot; :item=\&quot;item\&quot; :index=\&quot;index\&quot;></slot>\n    </template>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \&quot;sun\&quot;,\n  data() {\n    return {\n      slots: ['slot1', 'slot2', 'slot3'],\n      item: {}\n    }\n  }\n}\n</script>\n```\n\n**`Sun.jsx`**\n\n```jsx\nconst Sun = Vue.component('sun', {\n  data() {\n    return {\n      slots: ['slot1', 'slot2', 'slot3'],\n      item: {}\n    }\n  },\n  render() {\n    return (\n      <div className=\&quot;sun\&quot;>\n        {this.slots.map((name, index) => {\n          this.$scopedSlots[name](this.item, index)\n        })}\n      </div>\n    )\n  }\n})\n```&quot;],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;data&quot;:[0,{&quot;author&quot;:[0,&quot;mfuu&quot;],&quot;pubDatetime&quot;:[3,&quot;2024-06-30T02:52:14.000Z&quot;],&quot;modDatetime&quot;:[3,&quot;2024-06-30T14:34:55.000Z&quot;],&quot;title&quot;:[0,&quot;Vue2使用slot跨组件传递信息&quot;],&quot;featured&quot;:[0,false],&quot;tags&quot;:[1,[[0,&quot;vue&quot;]]],&quot;description&quot;:[0,&quot;Vue2使用slot跨组件传递信息&quot;],&quot;discussionNumber&quot;:[0,6]}],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;Vue2与Vue3.md&quot;],&quot;slug&quot;:[0,&quot;vue2与vue3&quot;],&quot;body&quot;:[0,&quot;## 生命周期\n\n|     Vue2.x     |       Vue3.x     |\n|----------------|------------------|\n| `beforeCreate` | `setup`          |\n| `created`      | `setup`          |\n| `beforeMount`  | `onBeforeMount`  |\n| `mounted`      | `onMounted`      |\n| `beforeUpdate` | `onBeforeUpdate` |\n| `updated`      | `onUpdated`      |\n| `beforeDestroy`| `onBeforeUnmount`|\n| `destroyed`    | `onUnmounted`    |\n| `errorCaptured`| `onErrorCaptured`|\n\n\n整体来看变化不大，除了 `beforeCreate`、`created` 用 `setup` 代替外，其余的基本都是变更名称，但功能本质上未发生变化\n\n\n## 响应式原理\n\n### `Object.defineProperty`\n\nvue2 中无法实现对数组对象的深层监听，是因为组件每次渲染都是将 `data` 里的数据通过 `defineProperty` 进行响应式或者双向绑定，在此之前没有加上的属性是不会被绑定上的，也就不会触发更新渲染\n\n```js\nObject.defineProperty(Obj, 'name', {\n  enumerable: true, // 可枚举\n  configurable: true, // 可配置\n\n  get: function() {\n    return def\n  },\n  set: function(val) {\n    def = val\n  }\n})\n```\n\nVue2.x 针对数组的解决方案：对常用数组原型方法 `push`、`pop`、`shift`、`unshift`、`splice`、`sort`、`reverse` 进行了 hack 处理；并提供了 `Vue.set` 监听对象/数组新增属性。对象的新增/删除响应，还可以 `new` 一个新对象，新增则合并新属性和就对象，删除则将删除属性后的对象深拷贝给新对象。\n\n> `Object.defineProperty` 是可以监听数组已有元素的，但 Vue2 没有提供的原因是 **性能问题**\n\n### `Proxy`\n\n```js\nconst hanlder = {\n  get: function(obj, prop) {\n    return prop in obj ? obj[prop] : 'none'\n  },\n  set: function() {},\n  ...\n}\nconst p = new Proxy({}, handler)\np.a = 1;\np.b = undefined\nconsole.log(p.a, p.b) // 1, undefined\nconsole.log('c' in p, p.c) // false, 'none'\n```\n\n`defineProperty` 只能响应首次添加时的属性值，而 `Proxy` 监听的是整个数据整体，不需要关心里面有什么属性，而且 `Proxy` 的配置项丰富（一共13种），可以做更细致的事情\n\n\n\n## Diff 算法\n\n搬运 Vue3 patchChildren 源码。结合上文与源码，patchFlag帮助 diff 时区分静态节点，以及不同类型的动态节点。一定程度地减少节点本身及其属性的比对。\n\n```ts\nfunction patchChildren(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) {\n  // 获取新老孩子节点\n  const c1 = n1 &amp;&amp; n1.children\n  const c2 = n2.children\n  const prevShapeFlag = n1 ? n1.shapeFlag : 0\n  const { patchFlag, shapeFlag } = n2\n  \n  // 处理 patchFlag 大于 0 \n  if(patchFlag > 0) {\n    if(patchFlag &amp;&amp; PatchFlags.KEYED_FRAGMENT) {\n      // 存在 key\n      patchKeyedChildren()\n      return\n    } els if(patchFlag &amp;&amp; PatchFlags.UNKEYED_FRAGMENT) {\n      // 不存在 key\n      patchUnkeyedChildren()\n      return\n    }\n  }\n  \n  // 匹配是文本节点（静态）：移除老节点，设置文本节点\n  if(shapeFlag &amp;&amp; ShapeFlags.TEXT_CHILDREN) {\n    if (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) {\n      unmountChildren(c1 as VNode[], parentComponent, parentSuspense)\n    }\n    if (c2 !== c1) {\n      hostSetElementText(container, c2 as string)\n    }\n  } else {\n    // 匹配新老 Vnode 是数组，则全量比较；否则移除当前所有的节点\n    if (prevShapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) {\n      if (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) {\n        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense,...)\n      } else {\n        unmountChildren(c1 as VNode[], parentComponent, parentSuspense, true)\n      }\n    } else {\n      \n      if(prevShapeFlag &amp; ShapeFlags.TEXT_CHILDREN) {\n        hostSetElementText(container, )\n      } \n      if (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) {\n        mountChildren(c2 as VNodeArrayChildren, container,anchor,parentComponent,...)\n      }\n    }\n  }\n}\n```\n\n#### patchUnkeyedChildren 源码如下:\n\n```ts\nfunction patchUnkeyedChildren(c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) {\n  c1 = c1 || EMPTY_ARR\n  c2 = c2 || EMPTY_ARR\n  const oldLength = c1.length\n  const newLength = c2.length\n  const commonLength = Math.min(oldLength, newLength)\n  let i\n  for(i = 0; i < commonLength; i++) {\n    // 如果新 Vnode 已经挂载，则直接 clone 一份，否则新建一个节点\n    const nextChild = (c2[i] = optimized ? cloneIfMounted(c2[i] as Vnode)) : normalizeVnode(c2[i])\n    patch()\n  }\n  if(oldLength > newLength) {\n    // 移除多余的节点\n    unmountedChildren()\n  } else {\n    // 创建新的节点\n    mountChildren()\n  }\n  \n}\n```\n\n#### patchKeyedChildren源码如下，有运用最长递增序列的算法思想:\n\n```ts\nfunction patchKeyedChildren(c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) {\n  let i = 0;\n  const e1 = c1.length - 1\n  const e2 = c2.length - 1\n  const l2 = c2.length\n  \n  // 从头开始遍历，若新老节点是同一节点，执行 patch 更新差异；否则，跳出循环 \n  while(i <= e1 &amp;&amp; i <= e2) {\n    const n1 = c1[i]\n    const n2 = c2[i]\n    \n    if(isSameVnodeType) {\n      patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSvg, optimized)\n    } else {\n      break\n    }\n    i++\n  }\n  \n  // 从尾开始遍历，若新老节点是同一节点，执行 patch 更新差异；否则，跳出循环 \n  while(i <= e1 &amp;&amp; i <= e2) {\n    const n1 = c1[e1]\n    const n2 = c2[e2]\n    if(isSameVnodeType) {\n      patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSvg, optimized)\n    } else {\n      break\n    }\n    e1--\n    e2--\n  }\n  \n  // 仅存在需要新增的节点\n  if(i > e1) {    \n    if(i <= e2) {\n      const nextPos = e2 + 1\n      const anchor = nextPos < l2 ? c2[nextPos] : parentAnchor\n      while(i <= e2) {\n        patch(null, c2[i], container, parentAnchor, parentComponent, parentSuspense, isSvg, optimized)\n      }\n    }\n  }\n  \n  // 仅存在需要删除的节点\n  else if(i > e2) {\n    while(i <= e1) {\n      unmount(c1[i], parentComponent, parentSuspense, true)    \n    }\n  }\n  \n  // 新旧节点均未遍历完\n  // [i ... e1 + 1]: a b [c d e] f g\n  // [i ... e2 + 1]: a b [e d c h] f g\n  // i = 2, e1 = 4, e2 = 5\n  else {\n    const s1 = i\n    const s2 = i\n    // 缓存新 Vnode 剩余节点 上例即{e: 2, d: 3, c: 4, h: 5}\n    const keyToNewIndexMap = new Map()\n    for (i = s2; i <= e2; i++) {\n      const nextChild = (c2[i] = optimized\n          ? cloneIfMounted(c2[i] as VNode)\n          : normalizeVNode(c2[i]))\n      \n      if (nextChild.key != null) {\n        if (__DEV__ &amp;&amp; keyToNewIndexMap.has(nextChild.key)) {\n          warn(\n            `Duplicate keys found during update:`,\n             JSON.stringify(nextChild.key),\n            `Make sure keys are unique.`\n          )\n        }\n        keyToNewIndexMap.set(nextChild.key, i)\n      }\n    }\n  }\n  \n  let j = 0\n  // 记录即将 patch 的 新 Vnode 数量\n  let patched = 0\n  // 新 Vnode 剩余节点长度\n  const toBePatched = e2 - s2 + 1\n  // 是否移动标识\n  let moved = false\n  let maxNewindexSoFar = 0\n  \n  // 初始化 新老节点的对应关系（用于后续最大递增序列算法）\n  const newIndexToOldIndexMap = new Array(toBePatched)\n  for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0\n  \n  // 遍历老 Vnode 剩余节点\n  for (i = s1; i <= e1; i++) {\n    const prevChild = c1[i]\n    \n    // 代表当前新 Vnode 都已patch，剩余旧 Vnode 移除即可\n    if (patched >= toBePatched) {\n      unmount(prevChild, parentComponent, parentSuspense, true)\n      continue\n    }\n    \n    let newIndex\n    // 旧 Vnode 存在 key，则从 keyToNewIndexMap 获取\n    if (prevChild.key != null) {\n      newIndex = keyToNewIndexMap.get(prevChild.key)\n    // 旧 Vnode 不存在 key，则遍历新 Vnode 获取\n    } else {\n      for (j = s2; j <= e2; j++) {\n        if (newIndexToOldIndexMap[j - s2] === 0 &amp;&amp; isSameVNodeType(prevChild, c2[j] as VNode)){\n           newIndex = j\n           break\n        }\n      }           \n   }\n   \n   // 删除、更新节点\n   // 新 Vnode 没有 当前节点，移除\n   if (newIndex === undefined) {\n     unmount(prevChild, parentComponent, parentSuspense, true)\n   } else {\n     // 旧 Vnode 的下标位置 + 1，存储到对应 新 Vnode 的 Map 中\n     // + 1 处理是为了防止数组首位下标是 0 的情况，因为这里的 0 代表需创建新节点\n     newIndexToOldIndexMap[newIndex - s2] = i + 1\n     \n     // 若不是连续递增，则代表需要移动\n     if (newIndex >= maxNewIndexSoFar) {\n       maxNewIndexSoFar = newIndex\n     } else {\n       moved = true\n     }\n     \n     patch(prevChild,c2[newIndex],...)\n     patched++\n   }\n  }\n  \n  // 遍历结束，newIndexToOldIndexMap = {0:5, 1:4, 2:3, 3:0}\n  // 新建、移动节点\n  const increasingNewIndexSequence = moved\n  // 获取最长递增序列\n  ? getSequence(newIndexToOldIndexMap)\n  : EMPTY_ARR\n  \n  j = increasingNewIndexSequence.length - 1\n\n  for (i = toBePatched - 1; i >= 0; i--) {\n    const nextIndex = s2 + i\n    const nextChild = c2[nextIndex] as VNode\n    const anchor = extIndex + 1 < l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor\n    // 0 新建 Vnode\n    if (newIndexToOldIndexMap[i] === 0) {\n      patch(null,nextChild,...)\n    } else if (moved) {\n      // 移动节点\n      if (j < 0 || i !== increasingNewIndexSequence[j]) {\n        move(nextChild, container, anchor, MoveType.REORDER)\n      } else {\n        j--\n      }\n    }\n  }\n}\n```&quot;],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;data&quot;:[0,{&quot;author&quot;:[0,&quot;mfuu&quot;],&quot;pubDatetime&quot;:[3,&quot;2024-06-30T02:36:31.000Z&quot;],&quot;modDatetime&quot;:[3,&quot;2024-06-30T02:36:31.000Z&quot;],&quot;title&quot;:[0,&quot;Vue2 与 Vue3&quot;],&quot;featured&quot;:[0,false],&quot;tags&quot;:[1,[[0,&quot;vue&quot;]]],&quot;description&quot;:[0,&quot;Vue2 与 Vue3&quot;],&quot;discussionNumber&quot;:[0,5]}],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;浏览器存储.md&quot;],&quot;slug&quot;:[0,&quot;浏览器存储&quot;],&quot;body&quot;:[0,&quot;### cookie，localStorage，sessionStorage，indexDB\n\n| 特性 | cookie | localStorage | sessionStorage | indexDB |\n| ---- | ------ | ------------ | -------------- | ------- |\n| 数据生命周期 | 一般由服务器生成，可以设置过期时间 | 除非被清理，否则一直存在 | 页面关闭就清理 | 除非被清理，否则一直存在 |\n| 数据存储大小 | 4K | 5M | 5M | 无限 |\n| 与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 | 不参与 | 不参与 | 不参与 |\n\n从上表可以看大，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 `localStorage` 和 `sessionStorage`。对于不怎么改变的数据尽量使用 `localStorage` 存储，否则可以用 `sessionStorage` 存储。\n\n对于 `cookie`，我们还需要注意安全性\n\n| 属性 | 作用 |\n| ---- | ---- |\n| value | 如果用于保存用户登陆状态，应该将值加密，不能使用明文的用户标识 |\n| http-only | 不能通过 JS 访问 Cookie，减少 XSS 攻击 |\n| secure | 只能在协议为 HTTPS 的请求中携带 |\n| same-site | 规定浏览器不能再跨域请求中携带 Cookie，减少 CSRF 攻击 |\n\n### Service Worker\n\n> Service Worker 本质上充当 Web 应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。它们还允许访问推送通知和后台同步API\n\n目前该技术通常用来做缓存文件，提高首屏速度，可以试着来实现这个功能：\n\n```js\n// index.js\nif (navigator.serviceWorker) {\n  navigator.serviceWorker.register('sw.js')\n  .then(function(registration) {\n    console.log('service worker 注册成功')\n  })\n  .catch(function(err) {\n    console.log('service worker 注册失败')\n  })\n}\n// sw.js\n// 监听 install 事件，回调中缓存所需文件\nself.addEventListener('install', e => {\n  e.waitUntill(caches.open('my-code').then(function(cache) {\n    return cache.addAll(['./index.html', './index.js'])\n  }))\n})\n// 拦截所有请求事件，如果缓存中已经有请求的数据就直接用缓存，否则去请求数据\nself.addEventListener('fetch', e => {\n  e.respondWith(caches.match(e.request).then(function(response) {\n    if (response) {\n      return response\n    }\n    console.log('fetch source')\n  }))\n})\n```&quot;],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;data&quot;:[0,{&quot;author&quot;:[0,&quot;mfuu&quot;],&quot;pubDatetime&quot;:[3,&quot;2024-06-29T03:27:28.000Z&quot;],&quot;modDatetime&quot;:[3,&quot;2024-06-29T07:08:19.000Z&quot;],&quot;title&quot;:[0,&quot;浏览器存储&quot;],&quot;featured&quot;:[0,false],&quot;tags&quot;:[1,[[0,&quot;web&quot;]]],&quot;description&quot;:[0,&quot;浏览器存储&quot;],&quot;discussionNumber&quot;:[0,1]}],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;浏览器渲染机制.md&quot;],&quot;slug&quot;:[0,&quot;浏览器渲染机制&quot;],&quot;body&quot;:[0,&quot;## 渲染流程\n浏览器的渲染机制一般分为以下几个步骤：\n* 1. 处理 HTML 并构建 DOM 树\n* 2. 处理 CSS 构建 CSSOM 树\n* 3. 将 DOM 树与 CSSOM 树合并成一个渲染树\n* 4. 根据渲染树来布局，计算每个节点的位置\n* 5. 调用 GPU 绘制，合成图层，显示在屏幕上\n\n![CSSOM](https://user-images.githubusercontent.com/51625532/157193329-4754aed0-a2ce-4336-a9bc-63c879725162.png)\n\n在构建 CSSOM 树时，会阻塞渲染，直到 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢\n\n当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM\n\n### Load 和 DOMContentLoaded 区别\n\nLoad 事件触发代表页面中的 DOM、CSS、JS、图片已经全部加载完毕\n\nDOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS、JS、图片加载\n\n## 图层\n\n一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用\n\n通过以下几个常用的属性可以生成新图层：\n\n* 3D 变换：`translate3d`，`translate2d`\n* `will-change`\n* `video`、`iframe`标签\n* 通过动画实现的 `opacity` 动画转换\n* `position: fixed`\n\n## 重绘（Repaint）和回流（Reflow）\n\n重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大\n\n* 重绘是当节点需要更改外观而不会影响布局，比如 `color` 属性值变更\n* 回流是布局或几何属性需要改变\n\n回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流\n\n所以以下几个动作可能会导致性能问题：\n\n* 改变 window 大小\n* 改变字体\n* 添加或删除样式\n* 文字改变\n* 定位或浮动\n* 盒模型\n\n重绘和回流与 EventLoop 有关：\n\n* 1. 当 EventLoop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次\n* 2. 然后判断是否有 `resize` 或者 `scroll`，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 16ms 才会触发一次，并且自带节流功能\n* 3. 判断是否触发了 media query\n* 4. 更新动画并且发送事件\n* 5. 判断是否有全屏操作事件\n* 6. 执行 `requestAnimationFrame` 回调\n* 7. 执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载，但是兼容性不好\n* 8. 更新界面\n* 9.以上就是一帧中可能会做的事。如果在一帧中有空闲时间，就会去执行 `requestIdleCallback` 回调\n\n## 减少重绘与回流\n\n* 使用 `trasnlate` 替代 `top`\n\n  ```html\n  <div class=\&quot;block\&quot;></div>\n  <style>\n    .block {\n      position: absolute;\n      top: 50px;\n      height: 100px;\n      width: 100px;\n      background-color: blue;\n    }\n  </style>\n  <script>\n    setTimeout(() => {\n      // 引起回流\n      document.querySelector('.block').style.top = '100px'\n    })\n  </script>\n  ```\n\n* 使用 `visibility` 替换 `display: none`，因为前者只会引起重绘，后者会引发回流\n* 把 DOM 离线后修改。比如：先把 DOM 给 `display: none` （有一次 Reflow），然后进行修改，修改完成后再把它显示出来\n* 不要把 DOM 节点的属性值放在一个循环里当成循环里的变量\n\n  ```js\n  for(let i = 0; i < 50; i++) {\n    // 获取 offsetTop 会导致回流，因为需要去获取正确的值\n    console.log(document.querySelector('.block').style.offsetTop)\n  }\n  ```\n\n* 避免使用 table 布局，可能很小的改动都会造成整个 table 重新布局\n* 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame`\n* CSS 选择符从右往左匹配查找，避免 DOM 深度过深\n* 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 `video` 标签，浏览器会自动将该节点变为图层\n\n**参考文章：**\n\n* https://html.spec.whatwg.org/multipage/webappapis.html#webappapis&quot;],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;data&quot;:[0,{&quot;author&quot;:[0,&quot;mfuu&quot;],&quot;pubDatetime&quot;:[3,&quot;2024-06-29T04:13:58.000Z&quot;],&quot;modDatetime&quot;:[3,&quot;2024-06-29T07:04:56.000Z&quot;],&quot;title&quot;:[0,&quot;浏览器渲染机制&quot;],&quot;featured&quot;:[0,false],&quot;tags&quot;:[1,[[0,&quot;web&quot;]]],&quot;description&quot;:[0,&quot;浏览器渲染机制&quot;],&quot;discussionNumber&quot;:[0,2]}],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;前端安全.md&quot;],&quot;slug&quot;:[0,&quot;前端安全&quot;],&quot;body&quot;:[0,&quot;## XSS\n\n> XSS(Cross-site scripting) 是一种网站应用程式的安全漏洞攻击，是代码注入的一种。它允许恶意使用者将程式代码注入到网页上，其他使用者在观看网页时就受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言\n\n> XSS 攻击分为三种：反射型，存储型，DOM-based\n\n### 攻击方式\n\n* XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站\n\n```html\n<!-- http://wwww.xxx.com?name=<script>alert(1)</script> -->\n<div>{{ name }}</div>\n```\n\n上述 URL 输入可能会将 HTML 改为 `<div><script>alert(1)</script></div>`，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 `DOM-based` 攻击\n\n### 防御方式\n\n最普遍的做法就是转义输入输出的内容，对于引号，尖括号，斜杠进行转义\n\n```js\nfunction escape(str) {\n  str = str.replace(/&amp;/g, \&quot;&amp;amp;\&quot;);\n  str = str.replace(/</g, \&quot;&amp;lt;\&quot;);\n  str = str.replace(/>/g, \&quot;&amp;gt;\&quot;);\n  str = str.replace(/\&quot;/g, \&quot;&amp;quto;\&quot;);\n  str = str.replace(/'/g, \&quot;&amp;##39;\&quot;);\n  str = str.replace(/`/g, \&quot;&amp;##96;\&quot;);\n  str = str.replace(/\\//g, \&quot;&amp;##x2F;\&quot;);\n  return str;\n}\n```\n\n通过转义可以将 `<script>alert(1)</script>` 变成 `&amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;##x2F;script&amp;gt;`\n\n> 对于富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的方式，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性是在太多，更加推荐使用白名单的方式\n\n```js\nconst xss = require('xss')\nconst html = xss('<h1 id=\&quot;title\&quot;>XSS Demo</h1><script>alert(\&quot;xss\&quot;);</script>')\n// <h1>XSS Demo</h1>&amp;lt;script&amp;gt;alert(\&quot;xss\&quot;);&amp;lt;/script&amp;gt;\n```\n\n### cookie 如何防范 XSS 攻击\n\n* `httpOnly`: 这个属性可以防止 XSS，它会禁用 JavaScript 脚本来访问 cookie\n* `secure`: 这个属性告诉浏览器仅在请求为 https 时发送 cookie，具体内容可以查看[Cookie的使用](https://mfuu.github.io/2020/02/02/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/#cookie)\n\n\n## CSRF\n\n> CSRF(Cross-site request forgery) 就是利用用户的登录状态发起恶意请求\n> CSRF - 跨站请求伪造，是一种常见的攻击方式。指 A 网站正常登录后，cookie 正常保存登录信息，网站 B 通过某种方式调用 A 网站接口进行操作，网站 A 的接口会在请求时自动带上 cookie\n\n### 攻击方式\n\n![403560712-54fdb1994e6c50a3_fix732](https://user-images.githubusercontent.com/51625532/178668200-422bd6f6-d167-4e27-b3a3-cec74dc06f3d.png)\n\n### 防御方式\n\n* 使用 token\n  服务器产生一个 token 存在 session 中，同时将 token 发送给客户端，客户端提交表单时带上该 token，服务器验证 token 与 session 是否一致，一致就允许访问，否则拒绝访问\n\n* referer 验证\n  referer 指的是页面请求来源，意思是，只接受本站的请求，服务器才做响应，如果不是就拦截\n\n* SameSite Cookie\n\n* 使用验证码\n  对于重要请求，要求用户输入验证码，强制用户必须与应用进行交互，才能完成最终请求\n\n\n> CSRF 攻击，仅仅是利用了 http 携带 cookie 的特性进行攻击，但是攻击站点还是无法得到被攻击站点的 cookie。与 XSS 不同，XSS 是直接通过拿到 Cookie 等信息进行攻击\n\n**CSRF 怎么获取用户的登录态**\n\n> 攻击全程不需要获取 cookie，只是在危险的网站欺骗用户去点击已登录的网站链接，利用已登录的网站自动发送 cookie 达到目的、因为 http 请求都会带着请求目标域下的 cookie，向同一个服务器发请求时会带上浏览器保存的 cookie，不管从哪个网站向目标网站发请求\n\n\n## 点击劫持\n\n> 点击劫持就像是将一个危险网站设置透明，然后在其上方设置一个按钮，当你点击这个按钮的时候，就会触发底部恶意网站的某些事件\n\n### 防御方式\n\n* 设置 http 响应头 `X-Frame-Options`\n  `X-Frame-Options` 响应头是用来给浏览器指示允许一个页面可否在 `<frame>`, `<iframe>` 或者 `<object>` 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去\n\n* 使用 CSP(Content Security Policy) 内容安全策略\n\n## XS-Leaks\n\n> XS-Leaks 即跨站泄露。\n> XS-Leaks 利用了对 HTTP 缓存进行查询的机制，通过对资源缓存的判断进而推断出当前用户的相关信息。\n\n### 攻击方式\n\nXS-Leaks 攻击的主要流程如下：\n\n* 1. 删除特定网站的缓存资源\n* 2. 强制浏览器刷新网站\n* 3. 检查浏览器是否缓存了在 1 中删除的资源\n\n![2522384929-9f77456b1e725da9_fix732](https://user-images.githubusercontent.com/51625532/178669781-3d826593-21c2-4e3f-a29e-0ba926bb3192.png)\n\n### 防御方式\n\nCSRF 的防御手段同样可以让 XS-Leaks 对带鉴权的请求访问无效，从而降低危险。当然有些时候这种攻击其实并不需要鉴权就能达成目的，因此 CSRF 的防御手段并不能做到完美抵御，所以在浏览器层面增加缓存分区就显得非常有必要了\n\n* 设置 SameSite Cookie\n* CSRF Token\n* 浏览器支持缓存分区&quot;],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;data&quot;:[0,{&quot;author&quot;:[0,&quot;mfuu&quot;],&quot;pubDatetime&quot;:[3,&quot;2024-06-29T06:39:58.000Z&quot;],&quot;modDatetime&quot;:[3,&quot;2024-06-29T06:43:11.000Z&quot;],&quot;title&quot;:[0,&quot;前端安全&quot;],&quot;featured&quot;:[0,false],&quot;tags&quot;:[1,[[0,&quot;web&quot;]]],&quot;description&quot;:[0,&quot;前端安全&quot;],&quot;discussionNumber&quot;:[0,3]}],&quot;render&quot;:[0,null]}]]]}" ssr="" client="load" opts="{&quot;name&quot;:&quot;SearchBar&quot;,&quot;value&quot;:true}" await-children=""><label class="block relative"><span class="flex absolute inset-y-0 items-center left-0 opacity-75 pl-2"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M19.023 16.977a35.13 35.13 0 0 1-1.367-1.384c-.372-.378-.596-.653-.596-.653l-2.8-1.337A6.962 6.962 0 0 0 16 9c0-3.859-3.14-7-7-7S2 5.141 2 9s3.14 7 7 7c1.763 0 3.37-.66 4.603-1.739l1.337 2.8s.275.224.653.596c.387.363.896.854 1.384 1.367l1.358 1.392.604.646 2.121-2.121-.646-.604c-.379-.372-.885-.866-1.391-1.36zM9 14c-2.757 0-5-2.243-5-5s2.243-5 5-5 5 2.243 5 5-2.243 5-5 5z"></path></svg><span class="sr-only">Search</span></span><input class="block bg-skin-fill border border-opacity-40 border-skin-fill focus:border-skin-accent focus:outline-none pl-10 placeholder:italic placeholder:text-opacity-75 pr-3 py-3 rounded w-full" placeholder="Search for anything..." type="text" name="search" autocomplete="off" value=""></label><ul></ul><!--astro:end--></astro-island>  </main>  <footer class="astro-sz7xmlte mt-auto"> <div class="max-w-3xl mx-auto px-0"> <hr class="border-skin-line" aria-hidden="true"> </div> <div class="astro-sz7xmlte footer-wrapper"> <div class="astro-upu6fzxr flex social-icons"> <a href="https://github.com/mfuu/gdb" class="astro-upu6fzxr group hover:text-skin-accent inline-block link-button" title=" GDB on Github"> <svg xmlns="http://www.w3.org/2000/svg" class="icon-tabler" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
    <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path>
  </svg> <span class="astro-upu6fzxr sr-only"> GDB on Github</span> </a> </div>  <div class="astro-sz7xmlte copyright-wrapper"> <span class="astro-sz7xmlte">Copyright © 2025</span> <span class="astro-sz7xmlte separator">&nbsp;|&nbsp;</span> <span class="astro-sz7xmlte">All rights reserved.</span> </div> </div> </footer>   </body></html>